import itertools
    
# Run a system of pool_size processes on the given method
def run(pool_size, main_loop, method):
    # Create a context for sending messages to bots and sockets
    context = Context(pool_size)
    # Initialize processes
    processes = [method(context, i) for i in xrange(0, pool_size)]
    # Return the first element generated by main_loop that is not null
    return next(itertools.dropwhile(lambda _: not _, main_loop(context, processes)))

# Main loop: run processes and manage messages
def main_loop(context, processes):
    # Remove messages matching a filter from the message queues
    def _discard_messages(filter):
        for queue in context.message_queues:
            queue[:] = (msg for msg in queue if not filter(msg))
    # Add messages from the temporary message queues to the message queues
    def _dequeue_tmp_message_queues():
        context.message_queues[:] = (context.message_queues[i] + context.tmp_message_queues[i] for i in xrange(0, context.pool_size))
        context.tmp_message_queues[:] = ([] for i in xrange(0, context.pool_size))
    # Main loop
    while any(processes):
        # Allow decorators to do a pre processing before next loop
        yield
        # Run the next step
        processes[:] = (process if process and not next(process) else None for process in processes)
        # Discard all read messages from queues
        _discard_messages(lambda msg: msg["read"])
        # Process messages from temporary message queues
        _dequeue_tmp_message_queues()
        # Allow decorators to do a post processing before next loop
        yield
    # Done
    yield True

# Context allowing for processes to know about the system and interact together
class Context(dict):
    def __init__(self, pool_size):
        super(Context, self).__init__()
        self["pool_size"] = pool_size
        self["tmp_message_queues"] = [[] for _ in xrange(0, pool_size)]
        self["message_queues"] = [[] for _ in xrange(0, pool_size)]
        self["groups"] = {}
        
    def __getattr__(self, attr):
        return self[attr]
    
    def __setattr__(self, attr, value):
        self[attr] = value

############
# Messages #
############

# Return all received messages matching a filter
def _messages(context, receiver, filter):
    return (msg for msg in context.message_queues[receiver] if not msg["read"] and filter(msg))
    
# Send a message to all elements in receivers
def send(context, sender, receivers, message):
    for receiver in receivers:
        context.tmp_message_queues[receiver].append({
            "sender": sender,
            "message": message,
            "read": False
        })
        yield receiver

# Return and mark as read all received messages matching a filter
def recv(context, receiver, filter):
    for msg in _messages(context, receiver, filter):
        msg["read"] = True
        yield msg
        
# Indicate if a message matching a filter has been received
def has_message(context, receiver, filter):
    return len([_ for _ in _messages(context, receiver, filter)]) != 0
    
# Send filter: send to all processes in the pool
def send_all(context, sender):
    return (_ for _ in xrange(0, context.pool_size) if _ != sender)
        
# Send filter: send to all processes in a group
def send_group(context, sender, group):
    return (_ for _ in get_group_processes(context, group) if _ != sender)

# Send filter: send to all processes in a list
def send_to(context, sender, *args):
    return (_ for _ in args if _ != sender)
        
# Recv filter: receive from all processes in the pool
def recv_all():
    return lambda message: True
    
# Recv filter: receive from all processes in a list
def recv_from(*args):
    def _recv_from(message):
        return message["sender"] in args
    return _recv_from

##########
# Groups #
##########

# Get all processes in a group
def get_group_processes(context, group):
    return (_ for _ in context.groups[group]) if group in context.groups else ()
        
# Groups
def join(context, process, group):
    context.groups.setdefault(group, set()).add(process)
        
def leave(context, process, group):
    groups = context.groups
    if groups.has_key(group):
        groups[group].remove(process)
        if len(groups[group]) == 0:
            del groups[group]
           
##########
# Tests #
##########
 
# Test running the system
def test_run(context, process):
    for i in xrange(1, 3 + process):
        print "process %d: step %d" % (process, i)
        yield
    yield True
       
# Test sending messages between processes 
def test_send(context, process):
    # Send message from process 0 to everyone
    if process == 0:
        print context
        sent_to = [_ for _ in send(context, process, send_all(context, 0), 1)]
        assert len(sent_to) == 2, "Message not sent to everyone"
        assert 1 in sent_to and 2 in sent_to, "Message sent to wrong process"
    yield
    # Check that process 1 and 2 received a message from process 0
    if process == 0:
        print context
        assert not has_message(context, process, recv_all()), "Message received"
    else:
        assert has_message(context, process, recv_all()), "No message received"
        msg = next(recv(context, process, recv_all()))
        msg["sender"] == 0, "Wrong message received"
        msg["message"] == 1, "Wrong message received"
    yield
    # Check that there is no received message remaining
    if process == 0:
        print context
    assert not has_message(context, process, recv_all()), "Message received"
    yield
    
# Test sending messages to processes in a group
def test_send_group(context, process):
    # Send message to processes in group 1
    if process == 0:
        sent_to = [_ for _ in send(context, process, send_group(context, process, 1), 1)]
        print sent_to
    yield
    # Check message has been received
    if process != 0:
        assert has_message(context, process, recv_all()), "No message received"
        msg = next(recv(context, process, recv_all()))
        msg["sender"] == 0, "Wrong message received"
        msg["message"] == 1, "Wrong message received"

# Test creating and joining groups
def test_groups(context, process):
    if process == 0:
        print context
    # All process join group 1
    join(context, process, 1)
    yield
    assert process in get_group_processes(context, 1), "Failed to join group"
    if process == 0:
        print context
    # Send message to processes in group 1
    if process == 0:
        sent_to = [_ for _ in send(context, process, send_group(context, process, 1), 1)]
        print sent_to
    yield
    # Check message has been received
    if process != 0:
        assert has_message(context, process, recv_all()), "No message received"
        msg = next(recv(context, process, recv_all()))
        msg["sender"] == 0, "Wrong message received"
        msg["message"] == 1, "Wrong message received"
    yield
    # All process join group 2
    join(context, process, 2)
    yield
    assert process in get_group_processes(context, 2), "Failed to join group"
    if process == 0:
        print context
    # All process leave group 1
    leave(context, process, 1)
    yield
    assert process not in get_group_processes(context, 1), "Failed to leave group"
    if process == 0:
        print context
        
if __name__ == '__main__':
    run(3, main_loop, test_run)
    run(3, main_loop, test_send)
    run(3, main_loop, test_send_group)
    run(3, main_loop, test_groups)
    